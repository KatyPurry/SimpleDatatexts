name: CurseForge Comment Notifications

on:
  schedule:
    - cron: "*/10 * * * *" # every 10 minutes (GitHub may be unreliable)
  workflow_dispatch:
  repository_dispatch:
    types: [run-cf-tracker]

jobs:
  scrape-comments:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install dependencies
        run: npm install puppeteer node-fetch

      - name: Restore state from GitHub Gist
        run: mkdir -p cf-state

      - name: Scrape CurseForge comments and post to Discord
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
          GIST_ID: ${{ secrets.GIST_ID }}
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          node <<'EOF'
          import puppeteer from "puppeteer";
          import fs from "fs";
          import fetch from "node-fetch";

          const GIST_ID = process.env.GIST_ID;
          const GH_TOKEN = process.env.GH_TOKEN;

          const stateDir = "cf-state";
          const stateFile = `${stateDir}/curseforge-state.json`;
          fs.mkdirSync(stateDir, { recursive: true });

          let state = {};
          if (GIST_ID) {
            try {
              const res = await fetch(`https://api.github.com/gists/${GIST_ID}`, {
                headers: { Authorization: `token ${GH_TOKEN}` }
              });
              if (res.ok) {
                const gist = await res.json();
                const stateContent = gist.files["curseforge-state.json"]?.content;
                if (stateContent) {
                  state = JSON.parse(stateContent);
                  console.log("State loaded from Gist:", JSON.stringify(state));
                } else {
                  console.log("No state file found in Gist, starting fresh");
                }
              } else {
                console.log(`Failed to fetch Gist: ${res.status}`);
              }
            } catch (e) {
              console.log("Could not fetch state from Gist, starting fresh:", e.message);
            }
          } else {
            console.log("GIST_ID not set, state will not persist");
          }

          const browser = await puppeteer.launch({ args: ["--no-sandbox"] });
          const page = await browser.newPage();
          page.setDefaultTimeout(10000);

          const PROJECTS = [
            { slug: "simpledatatexts", name: "SimpleDatatexts" },
            { slug: "lootspecswapper", name: "Loot Spec Swapper" },
            { slug: "emoteldb", name: "EmoteLDB" }
          ];

          for (const project of PROJECTS) {
            const url = `https://www.curseforge.com/wow/addons/${project.slug}/comments`;
            const newComments = [];

            try {
              await page.goto(url, { waitUntil: "networkidle2" });

              // Wait longer for dynamic content to load
              await new Promise(resolve => setTimeout(resolve, 3000));

              // Debug: Log what elements exist on the page
              const debugInfo = await page.evaluate(() => {
                const allElements = document.querySelectorAll("[class*='comment']");
                const sampleElements = Array.from(allElements).slice(0, 3).map(el => ({
                  tag: el.tagName,
                  className: el.className,
                  innerHTML: el.innerHTML.substring(0, 100)
                }));
                return {
                  commentElementsFound: allElements.length,
                  sampleElements: sampleElements
                };
              });
              console.log(`Debug info for ${project.name}:`, JSON.stringify(debugInfo, null, 2));

              const comments = await page.evaluate(() => {
                return Array.from(document.querySelectorAll(".comments-list li"))
                  .slice(0, 50) // Limit to recent 50
                  .map((node, index) => {
                    // Extract comment ID from .num div
                    const commentNum = node.querySelector(".num")?.innerText?.trim();
                    
                    // Extract author from .author-name span
                    const author = node.querySelector(".author-name .ellipsis")?.innerText?.trim() || "Unknown";
                    
                    // Extract body from .text div
                    const body = node.querySelector(".text")?.innerText?.trim() || "";
                    
                    // Extract timestamp from .date span
                    const timestamp = node.querySelector(".date span")?.innerText?.trim() || new Date().toISOString();

                    return {
                      id: commentNum,
                      author,
                      body,
                      timestamp
                    };
                  })
                  .filter(c => c.id); // Only keep comments with valid IDs
              });

              console.log(`Found ${comments.length} comments for ${project.name}`);
              console.log(`Previous last ID for ${project.slug}: ${state[project.slug] || 'none'}`);

              for (const comment of comments.reverse()) {
                const lastId = state[project.slug] || 0;
                const isNew = parseInt(comment.id) > parseInt(lastId);
                
                if (!isNew) {
                  console.log(`Skipping comment ${comment.id} (not newer than ${lastId})`);
                  continue;
                }

                newComments.push(comment);
                state[project.slug] = comment.id;

                // Debug output for new comment
                console.log(`\n--- NEW COMMENT: ${project.name} ---`);
                console.log(`ID:        ${comment.id}`);
                console.log(`Author:    ${comment.author}`);
                console.log(`Timestamp: ${comment.timestamp}`);
                console.log(`Body:      ${comment.body}`);
                console.log(`-----------------------------------\n`);
              }

              // Send batched message if there are new comments
              if (newComments.length > 0) {
                const description = newComments
                  .map(c => `**${c.author}**: ${c.body.substring(0, 200)}${c.body.length > 200 ? '...' : ''}`)
                  .join("\n\n");

                const msg = {
                  embeds: [{
                    title: `ðŸ’¬ ${newComments.length} new comment(s) on ${project.name}`,
                    description: description.substring(0, 2048),
                    url: url,
                    color: 0xFF6E00,
                    footer: { text: `Latest: #${newComments[0].id}` }
                  }]
                };

                try {
                  const res = await fetch(process.env.DISCORD_WEBHOOK, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(msg)
                  });
                  if (!res.ok) console.log(`Discord error (${project.name}): ${res.status}`);
                } catch (e) {
                  console.log(`Failed to post to Discord for ${project.name}:`, e.message);
                }
              } else {
                console.log(`No new comments for ${project.name}`);
              }

            } catch (e) {
              console.log(`Error scraping ${project.name}:`, e.message);
            }
          }

          await browser.close();

          // Save updated state to Gist
          if (GIST_ID) {
            try {
              console.log("Attempting to save state to Gist:", JSON.stringify(state));
              const updateRes = await fetch(`https://api.github.com/gists/${GIST_ID}`, {
                method: "PATCH",
                headers: {
                  Authorization: `token ${GH_TOKEN}`,
                  "Content-Type": "application/json"
                },
                body: JSON.stringify({
                  files: {
                    "curseforge-state.json": {
                      content: JSON.stringify(state, null, 2)
                    }
                  }
                })
              });
              if (updateRes.ok) {
                console.log("State saved to Gist successfully");
              } else {
                console.log(`Failed to update Gist: ${updateRes.status}`);
                const errorBody = await updateRes.text();
                console.log(`Error details: ${errorBody}`);
              }
            } catch (e) {
              console.log("Failed to save state to Gist:", e.message);
            }
          } else {
            console.log("GIST_ID not set, state will not persist");
          }
          EOF